import json
from functools import reduce
from itertools import chain

# here should be the data path generated by printInfo
with open("scripts/defInfos.json", 'r') as fp:
  data = json.load(fp)

def generate_latex_content(json_data):
    definitions = []
    lemmas = []

    name_to_namespaces = {}
    for item in json_data:
        name = item["name"]
        name_without_namespace = name.split('.')[-1]
        s = name_to_namespaces.get(name_without_namespace) or set()
        s.add(name.rsplit('.', maxsplit=2)[0])
        name_to_namespaces[name_without_namespace] = s

    # check namespace conflict
    def to_label(name):
        name_without_namespace = name.split('.')[-1]
        if len(name_to_namespaces[name_without_namespace]) > 1:
            label = name
        else:
            label = name_without_namespace
        return label.replace("'", "â€™") # a workaround to avoid invalid html anchor when there is `'` on the name
    
    def to_title(name):
        # line break to avoid too long
        linebreak_seq = []
        buf = ""
        def handle_segment():
            if linebreak_seq and len(linebreak_seq[-1]) + len(buf) <= 12:
                linebreak_seq[-1] += buf
                return ""
            else:
                linebreak_seq.append(buf)
                return ""
        for c in name:
            buf += c
            if c in "._":
                buf = handle_segment()
        buf = handle_segment()
        if buf:
            linebreak_seq.append(buf)
        # line break via "HTML-Like Labels" https://www.graphviz.org/doc/info/shapes.html#html
        label = "<BR/>".join(linebreak_seq)
        return f"<{label}>"

    for item in json_data:
        name = item["name"]
        module = item["module"]
        is_thm = item["isThm"]
        is_statement_sorry = item["statementSorry"]
        is_proof_sorry = item["proofSorry"]
        docstring = item["docstring"]
        statement_uses = item["statementUses"]
        proof_uses = item["proofUses"]

        statement_lean_ok = "\\leanok" if not is_statement_sorry else ""
        proof_lean_ok = "\\leanok" if not is_proof_sorry else ""
        lean_ref = f"\\lean{{{name}}}"
        statement_uses_content = ""
        if statement_uses:
          processed_uses = (to_label(u) for u in statement_uses)
          statement_uses_content = "\\uses{" + ", ".join(processed_uses) + "}"

        proof_uses_content = ""
        if proof_uses:
          processed_uses = (to_label(u) for u in proof_uses)
          proof_uses_content = "\\uses{" + ", ".join(processed_uses) + "}"

        # \settitle command requires a patched version of plastexdepgraph:
        # https://github.com/WuProver/plastexdepgraph/tree/settitle.
        # it can be installed via
        # `pip install --force-reinstall https://github.com/WuProver/plastexdepgraph/archive/refs/heads/settitle.zip`
        content = f"""
        \\begin{{definition}}\\label{{{to_label(name)}}}
          \\settitle{{{to_title(name)}}}
          {lean_ref}
          {statement_uses_content}
          {statement_lean_ok}
          {docstring if docstring else ""}
        \\end{{definition}}""" if not is_thm else f"""
        \\begin{{lemma}}\\label{{{to_label(name)}}}
          \\settitle{{{to_title(name)}}}
          {lean_ref}
          {statement_uses_content}
          {statement_lean_ok}
          {docstring if docstring else ""}
        \\end{{lemma}}
        
        \\begin{{proof}}
          {proof_uses_content}
          {proof_lean_ok}
        \\end{{proof}}
        """

        if is_thm:
            lemmas.append(content)
        else:
            definitions.append(content)

    latex_output = f"""
    \\chapter{{Definitions}}
    {'\n'.join(definitions)}

    \\chapter{{Lemmas}}
    {'\n'.join(lemmas)}"""

    return latex_output

latex_content = generate_latex_content(data)

with open("scripts/content.tex", 'w', encoding='utf-8') as f:
    f.write(latex_content)