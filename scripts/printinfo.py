import json
from functools import reduce
from itertools import chain, pairwise
import subprocess

modules = {}

# here should be the data path generated by printInfo
with open("scripts/defInfos.json", 'r') as fp:
  data = json.load(fp)

def md_to_latex(md):
    result = subprocess.run(['pandoc', '-t', 'latex'], stdout=subprocess.PIPE, input=md.encode('utf-8'))
    assert result.returncode == 0
    return result.stdout.decode('utf-8').replace("\\def\\labelenumi{\\arabic{enumi}.}\n", "") # hack to make web blueprint work

def generate_latex_content(json_data):
    definitions = []
    lemmas = []

    name_to_namespaces = {}
    for item in json_data:
        name = item["name"]
        name_without_namespace = name.split('.')[-1]
        s = name_to_namespaces.get(name_without_namespace) or set()
        s.add(name.rsplit('.', maxsplit=2)[0])
        name_to_namespaces[name_without_namespace] = s

    # check namespace conflict
    def to_label(name):
        name_without_namespace = name.split('.')[-1]
        if len(name_to_namespaces[name_without_namespace]) > 1:
            label = name
        else:
            label = name_without_namespace
        return label.replace("'", "â€™") # a workaround to avoid invalid html anchor when there is `'` on the name
    
    def to_title(name):
        # line break to avoid too long
        linebreak_seq = []
        buf = ""
        def handle_segment():
            if linebreak_seq and len(linebreak_seq[-1]) + len(buf) <= 12:
                linebreak_seq[-1] += buf
                return ""
            else:
                linebreak_seq.append(buf)
                return ""
        for c in name:
            buf += c
            if c in "._":
                buf = handle_segment()
        buf = handle_segment()
        if buf:
            linebreak_seq.append(buf)
        # line break via "HTML-Like Labels" https://www.graphviz.org/doc/info/shapes.html#html
        label = "<BR/>".join(linebreak_seq)
        return f"<{label}>"

    def is_lemma(module, pos):
        global modules
        if pos is None:
            return False
        lines = modules.get(module) or [l.strip("\n") for l in open(module.replace(".", "/") + ".lean").readlines()]
        modules[module] = lines
        in_comment = False
        for l in lines[pos-1:]:
            if not in_comment:
                if l.startswith("lemma"):
                    return True
                elif l.startswith("theorem"):
                    return False
            for p in pairwise(l):
                if in_comment and p == "-/":
                    in_comment = False
                elif not in_comment and p == "/-":
                    in_comment = True


    for item in json_data:
        name = item["name"]
        module = item["module"]
        is_thm = item["isThm"]
        is_statement_sorry = item["statementSorry"]
        is_proof_sorry = item["proofSorry"]
        docstring = md_to_latex(item["docstring"] or "")
        statement_uses = item["statementUses"]
        proof_uses = item["proofUses"]
        pos = item["pos"]

        statement_lean_ok = "\\leanok" if not is_statement_sorry else ""
        proof_lean_ok = "\\leanok" if not is_proof_sorry else ""
        lean_ref = f"\\lean{{{name}}}"
        statement_uses_content = ""
        if statement_uses:
          processed_uses = (to_label(u) for u in statement_uses)
          statement_uses_content = "\\uses{" + ", ".join(processed_uses) + "}"

        proof_uses_content = ""
        if proof_uses:
          processed_uses = (to_label(u) for u in proof_uses)
          proof_uses_content = "\\uses{" + ", ".join(processed_uses) + "}"

        _backdash = "\\" # python3.10 workaround

        if is_thm:
            lemma = is_lemma(module, pos)

        # \settitle command requires a patched version of plastexdepgraph:
        # https://github.com/WuProver/plastexdepgraph/tree/settitle.
        # it can be installed via
        # `pip install --force-reinstall https://github.com/WuProver/plastexdepgraph/archive/refs/heads/settitle.zip`
        content = f"""
        \\begin{{definition}}[\\texttt{{{to_label(name).replace('_', _backdash+'_')}}}]\\label{{{to_label(name)}}}
          \\settitle{{{to_title(name)}}}
          {lean_ref}
          {statement_uses_content}
          {statement_lean_ok}
          {docstring if docstring else ""}
        \\end{{definition}}""" if not is_thm else f"""
        \\begin{{{"lemma" if lemma else "theorem"}}}[\\texttt{{{to_label(name).replace('_', _backdash+'_')}}}]\\label{{{to_label(name)}}}
          \\settitle{{{to_title(name)}}}
          {lean_ref}
          {statement_uses_content}
          {statement_lean_ok}
          {docstring if docstring else ""}
        \\end{{{"lemma" if lemma else "theorem"}}}
        
        \\begin{{proof}}
          {proof_uses_content}
          {proof_lean_ok}
        \\end{{proof}}
        """

        if is_thm:
            lemmas.append(content)
        else:
            definitions.append(content)

    _newline = "\n" # workaround for python3.10 where f-string expression part cannot include a backslash
    latex_output = f"""
    \\chapter{{Definitions}}
    {_newline.join(definitions)}

    \\chapter{{Lemmas}}
    {_newline.join(lemmas)}"""

    return latex_output

latex_content = generate_latex_content(data)

with open("scripts/content.tex", 'w', encoding='utf-8') as f:
    f.write(latex_content)
